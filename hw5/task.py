"""Иерархия классов для работы с медиа-файлами."""

from dataclasses import dataclass
from typing import Any, Callable, Protocol, TypeVar, overload

Data = TypeVar('Data')
"""Тип данных, которым оперирует файл."""

Strategy = Callable[[Any], Data]
"""Паттерн стратегия.

Позволит распилить логику загрузки данных со сторонних сервисов на отдельные методы, которые
придерживаются единого интерфейса.
"""


@dataclass
class Info:
    """Содержит всякую информацию о файле."""


@dataclass
class Meta:
    """Содержит всякую метаинформацию о файле."""


class Loader(Protocol):
    """Описывает интерфейс для загрузчика данных с какого-либо сервиса.

    В каждом Loader-е реализуется своя логика загрузки данных.
    Это позволяет убрать жесткую связь между файлом и способом получения данных, упрощенная
    реализация `Посетителя`.
    """

    def load(self) -> Data:
        """Логика загрузки данных."""


class Uploader(Protocol):
    """Описывает интерфейс для загрузки данных на сервер."""


class Convertor(Protocol):
    """Описывает интерфейс конверсии данных в выбранный формат."""


class MediaFile:
    """Описывает интерфейс для работы с медиа-данными.

    Для реализации хранения данных можно реализовать наследование от нужной структуры.
    Альтернативный путь - композиция, но тогда требуется реализовать __init__ с нужным контейнером.

    :example:
    >>> def reverse_colors(data: bytes) -> bytes: ...
    >>> def to_cloud(data: bytes): ...
    >>>
    >>> with MediaFile('path_to_image') as jpeg_image:
    >>>     new_data = jpeg_image.convert(reverse_colors)
    >>>     jpeg_image.update(new_data)
    >>>     jpeg_image.write()
    >>>     jpeg_image.upload(to_cloud)
    """
    def __init__(self, data: Data | None = None, info: Info | None = None, meta: Meta | None = None):
        """Инициализирует внутреннее хранилище, записывает туда данные.

        Данных на момент создание экземпляра еще может не быть, поэтому они Optional. Info и Meta не
        всегда требуются, чтоб не блокировали создание экземпляров, также делаем их Optional.
        """
        self.__container = data
        self.info = info
        self.meta = meta

    def __enter__(self):
        """Протокол контекстного менеджера."""
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Протокол контекстного менеджера для автоматического закрытия файла."""

    def __iter__(self):
        """Поддержка протокола итераций.

        Позволит реализовать построчное/побайтовое считывание данных из файла без необходимости
        дожидаться загрузку всего файла целиком
        """

    def __next__(self):
        """Протокол итераций позволит использовать файл в циклах и генераторных выражениях."""

    def open(self, path: str, mode: str):
        """Перед работой с файлом его возможно потребуется открыть, указав режим - чтение/запись."""

    def close(self):
        """Логика закрытия файла для корректного высвобождения ресурсов."""

    @overload
    def read(self, size: int): ...
    @overload
    def read(self, size: str): ...

    def read(self, size: str = 'all'):
        """Читает данные из файла.

        Может считать все данные, либо 1 строку, либо указанное кол-во байт. Также можно реализовать
        считывание с фильтром по каким-либо именованным параметрам. Может вернуть считанные данные,
        либо сохранить во внутреннем контейнере.
        """

    def write(self):
        """Записывает данные в конец файла, либо перезаписывает файл."""

    def update(self, data: Data):
        """Реализует логику добавления данных в уже существующую структуру."""

    def remove(self):
        """Позволяет удалить указанные данные из внутреннего контейнера."""

    def find(self) -> Data | None:
        """Позволяет искать указанные параметры по имени/позиции."""

    @staticmethod
    def create(data: Data) -> 'MediaFile':
        """Позволяет создать новый файл и проинициализировать его данными."""

    @staticmethod
    def download(loader: Loader or Strategy) -> Data:
        """Позволяет загрузить данные через специализированный загрузчик без жесткой привязки.

        Без предварительно валидации новые данные в файл лучше не добавлять, метод не должен быть
        inplace, так что можно его сделать staticmethod, чтоб загружать данные без инициализации
        экземпляра.

        Использование специализированных загрузчиков/конверторов позволяет расширять функционал,
        добавляя новые сущности, не меняя существующую.
        """

    def upload(self, uploader: 'Uploader' or Strategy):
        """Позволяет загрузить файл на сервер.

        Реализация по аналогии с методом download через специализированный загрузчик, который
        реализует логику загрузки и обновления файла на сервере.
        """

    def convert(self, convertor: 'Convertor' or Strategy):
        """Преобразовывает данные из файла в выбранный формат, используя целевой конвертор."""
